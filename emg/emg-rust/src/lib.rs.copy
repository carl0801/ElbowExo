use ndarray::{Array1, Array2, Axis};
use numpy::{PyArray1, PyArray2, PyReadonlyArray1, PyReadonlyArray2, ToPyArray};
use pyo3::prelude::*;
use ndarray_linalg::Inverse;
//use ndarray::prelude::*;
//use ndarray_linalg::Solve;
// use rayon::prelude::*;

/// Apply SOS filter forwards over the signal x.
fn sosfilt(x: &Array1<f64>, sos_matrix: &Array2<f64>, mut zi: Array2<f64>) -> Array1<f64> {
    let n_sections = sos_matrix.nrows();
    let mut y = Array1::<f64>::zeros(x.len());
    
    for (n, &x_n) in x.iter().enumerate() {
        let mut x_n = x_n;
        for section_idx in 0..n_sections {
            let section = sos_matrix.row(section_idx);
            let (b0, b1, b2, _a0, a1, a2) = (section[0], section[1], section[2], section[3], section[4], section[5]);
            
            // Apply direct form II transposed structure
            let y_n = b0 * x_n + zi[[section_idx, 0]];
            zi[[section_idx, 0]] = b1 * x_n - a1 * y_n + zi[[section_idx, 1]];
            zi[[section_idx, 1]] = b2 * x_n - a2 * y_n;


            // Update input for the next section
            x_n = y_n;
        }
        y[n] = x_n;
    }
    
    y
}

fn lfilter_zi(b: &Array1<f64>, a: &Array1<f64>) -> Array1<f64> {
    // Implementing lfilter_zi as given in your earlier function
    let n = a.len().max(b.len());
    let mut a = a.to_vec();
    let mut b = b.to_vec();

    // Normalize coefficients if necessary
    if a[0] != 1.0 {
        let norm = a[0];
        for coeff in b.iter_mut() {
            *coeff /= norm;
        }
        for coeff in a.iter_mut() {
            *coeff /= norm;
        }
    }

    // Pad a or b with zeros
    while b.len() < n {
        b.push(0.0);
    }
    while a.len() < n {
        a.push(0.0);
    }

    // Create identity matrix I - A
    let mut i_minus_a = Array2::<f64>::eye(n - 1);
    for (i, &ai) in a.iter().skip(1).enumerate() {
        i_minus_a[[i, i]] -= ai;
    }

    // Calculate the new B vector
    let b_section = &b[1..];
    let b_vec = Array1::from(b_section.iter().zip(a.iter().skip(1).map(|&x| x * b[0])).map(|(&bi, ai)| bi - ai).collect::<Vec<_>>());

    // Solve for zi using linear algebra
    // Note: This is a simplified version that assumes i_minus_a is invertible
    let zi = i_minus_a.inv().unwrap().dot(&b_vec);

    Array1::from(zi)
}

fn sosfilt_zi(sos: &Array2<f64>, g: f64) -> Array2<f64> {
    // Number of second-order sections
    let num_sections = sos.shape()[0];
    let mut zi = Array2::<f64>::zeros((num_sections, 2)); // Each section has two state variables

    for i in 0..num_sections {
        // Coefficients for the i-th SOS
        let b = Array1::from(vec![sos[[i, 0]], sos[[i, 1]], sos[[i, 2]]]);
        let a = Array1::from(vec![sos[[i, 3]], sos[[i, 4]], sos[[i, 5]]]);

        // Calculate the initial state for the current section
        let section_zi = lfilter_zi(&b, &a);
        zi.row_mut(i).assign(&section_zi);
    }

    // Scale the initial states by the gain
    zi *= g;

    zi
}

fn sosfiltfilt(sos_matrix: &Array2<f64>, x: &Array1<f64>) -> Array2<f64> {
    // call sosfilt() with zero zi guess
    //let y = sosfilt(x, sos_matrix, Array2::zeros((sos_matrix.nrows(), 2)));
    let zi = sosfilt_zi(sos_matrix, 1.0); // Provide a gain value
    zi
}

/// Apply an SOS filter forwards and backwards to achieve zero-phase filtering.
#[pyfunction]
#[pyo3(name = "sosfiltfilt")]
fn sosfiltfilt_python<'a>(
    py: Python<'a>,
    sos_matrix: PyReadonlyArray2<'a, f64>, 
    x: PyReadonlyArray1<'a, f64>
) -> PyResult<Bound<'a, PyArray2<f64>>> {

    // Convert PyReadonlyArray to ndarray ArrayView for processing
    let x = x.as_array();
    let sos_matrix = sos_matrix.as_array();
    let x_owned = x.to_owned();
    let sos_matrix_owned = sos_matrix.to_owned();

    // Apply the filter sosfiltfilt()
    let y_filtfilt = sosfiltfilt(&sos_matrix_owned, &x_owned);
    
    // Convert the result back to a Python array
    let result = y_filtfilt.to_pyarray_bound(py);
    Ok(result)
}


// Formats the sum of two numbers as string.
#[pyfunction]
fn sum_as_string(a: usize, b: usize) -> PyResult<String> {
    Ok((a + b).to_string())
}

// A Python module implemented in Rust.
#[pymodule]
fn emg_rust(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(sum_as_string, m)?)?;
    m.add_function(wrap_pyfunction!(sosfiltfilt_python, m)?)?;
    Ok(())
}